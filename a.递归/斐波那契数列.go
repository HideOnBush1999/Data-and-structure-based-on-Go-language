package main

import "fmt"

func f1(n int) int {
	if n == 1 || n == 2 {
		return 1
	}
	return f1(n-1) + f1(n-2)
}

// 尾递归
func f2(n int, a1, a2 int) int {
	if n == 1 {
		return a1
	}
	return f2(n-1, a2, a1+a2)
	// a1 变成了下一个数 a2
	// a2 变成了下一个数 a1 + a2
}

func main() {
	fmt.Println(f1(6))
	fmt.Println(f2(6, 1, 1)) // 斐波那契数列第一项和第二项都为 1
}

/* 尾递归的优点：尾递归是指递归函数在其递归调用处的最后一条语句是递归调用本身。
在普通递归中，每次递归调用都会创建一个新的函数调用帧并将其压入调用栈，导致调用栈的增长。而尾递归中，由于递归调用是最后一条语句，不需要保留当前函数的任何状态，可以直接替换当前函数的调用帧，从而避免了不必要的调用栈的增长。这样可以节省内存空间，并且避免了在递归层级很深时发生栈溢出的问题。
 */