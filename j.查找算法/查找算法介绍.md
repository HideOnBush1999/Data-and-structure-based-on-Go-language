## 常见的查找算法
1. 散列查找：也称哈希查找，有拉链法查找，也有线性探测法查找，拉链法使用数组链表结构，线性探测法使用数组。
2. 树查找：有搜索二叉树，平衡查找树如：红黑树，B树，AVL树，B+等，使用链表树结构。

## 散列查找（哈希查找）
是一种空间换时间的查找算法，依赖的数据结构称为哈希表或散列表

>Hash: 翻译为散列，哈希，主要指压缩映射，它将一个比较大的域空间映射到一个比较小的域空间。 
简单的说就是把任意长度的消息压缩到某一固定长度的消息摘要的函数。Hash 算法虽然是一种算法，但更像一种思想，没有一个固定的公式，只要符合这种思想的算法都称 Hash 算法。

首先有一个大数组，每当存一个键值对时，先把键进行哈希，计算出的哈希值是一个整数，使用这个整数对数组长度`取余`，映射到数组的某个下标，把该键值对存起来，取数据时按同样的步骤进行查找。

### 线性探测法
线性探测法实现的哈希表是一个大数组。

首先，哈希表数据结构会初始化 N 个大小的数组，然后存取键 key 时，会求键的哈希值 hash(key)，这是一个整数。然后与数组的大小进行取余：hash(key)%N，将会知道该键值对要存在数组的哪个位置。

如果数组该位置已经被之前的键值对占领了，也就是哈希冲突，那么会偏移加1，探测下个位置是否被占用，如果下个位置为空，那么占位，否则继续探测。查找时，也是查看该位置是否为该键，不是则继续往该位置的下一个位置查找。因为这个步骤是线性的，所以叫线性探测法。

因为线性探测法很少使用，我们接下来主要分析拉链法。

### 拉链法
拉链法实现的哈希表是一个数组链表，也就是数组中的元素是链表。数组链表很像一条条拉链，所以又叫拉链法查找。

首先，哈希表数据结构会初始化 N 个大小的数组，然后存取键 key 时，会求键的哈希值 hash(key)，这是一个整数。然后与数组的大小进行取余：hash(key)%N，将会知道该键值对要存在数组的哪个位置。

如果数组该位置已经被之前的键值对占领了，也就是哈希冲突，那么键值对会追加到之前键值对的后面，形成一条链表。

从上面我们可以看出来我们应该要尽量避免哈希冲突，所以我们追求具有很好随机分布性的哈希函数。目前有的哈希函数有很多，这次我们使用 xxHash 库


### 取余操作中的数组长度选择
可以选 `2^k` 作为数组长度，可以提高计算速度
> 恒等式 hash % 2^k = hash & (2^k-1)，表示截断二进制的位数，保留后面的 k 位
> 
> 哈希表数组长度 len=8
> 
> 存在一个哈希值 hash=165，二进制表示为 1010 0101
> 
> 所以： 
> 
> 165 % 8 
> 
> = 165 % 2^3
> 
> = 165 & (2^3-1)
> 
> = 165 & 7
> 
> = 1010 0101 & 0000 0111 
> 
> = 0000 0000 0101 
> 
> = 5

选择 2^k 长度会使得计算速度更快，但是相当于截断二进制后保留后面的 k 位，如果存在很多哈希值的值很大，位数超过了 k 位，而二进制后 k 位都相同，那么会导致大片哈希冲突。

即使如此，存在很大哈希值的情况很少发生，大部分哈希值的二进制位数都不会超过 k 位，因此编程语言 Golang 使用了这种 2^x 长度作为哈希表的数组长度。

另一个选择是选择素数，实际上 hash(key) % len 的分布是和 len 有关的，一组均匀分布的 hash(key) 在 len 是素数时才能做到均匀。

我们实现拉链哈希表的时候，为了数组扩容和计算更方便，仍然还是使用 2^x 的数组长度。